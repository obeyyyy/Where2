'use client';

import React, { useState, useEffect, useRef } from 'react';
import dynamic from 'next/dynamic';
import TripCard from '../components/TripCard';
import { AirportAutocomplete, AirportOption } from '../components/AirportAutocomplete';
import Image from 'next/image';
import airportsJson from 'airports-json';
import { motion, AnimatePresence } from 'framer-motion';
import { FiArrowRight, FiArrowLeft, FiCalendar, FiUsers, FiMapPin, FiDollarSign, FiGlobe } from 'react-icons/fi';
import { useTripCart } from '../components/TripCartContext';
import { useRouter } from 'next/navigation';

const Loading = dynamic(() => import('../components/loading'), { ssr: false });

type ViewState = 'initial' | 'dates' | 'details' | 'searching' | 'results' | 'error' | 'no-results';
type TripType = 'roundtrip' | 'oneway';

interface SearchParams {
  budget: number;
  currency: string;
  originType: 'Airport' | 'City' | 'Country';
  origin: string;
  destinationType: 'Airport' | 'City' | 'Country';
  destination: string;
  departureDate: string;
  returnDate: string;
  tripType: TripType;
  travelers: number;
  nights: number;
  includeHotels: boolean;
  useKiwi: boolean; // Kiwi/Amadeus toggle
  useDuffel: boolean; // Duffel toggle
}

interface FlightSegment {
  departure: {
    iataCode: string;
    at: string;
    terminal?: string;
  };
  arrival: {
    iataCode: string;
    at: string;
    terminal?: string;
  };
  carrierCode: string;
  number: string;
  aircraft: {
    code: string;
  };
  operating?: {
    carrierCode: string;
  };
}

interface FlightOffer {
  id: string;
  price: {
    total: string;
    currency: string;
    breakdown?: {
      outbound?: string;
      return?: string;
    };
  };
  itineraries: Array<{
    duration: string;
    segments: FlightSegment[];
  }>;
  destinationImage?: string;
}

interface TripDataResponse {
  data: FlightOffer[];
  meta?: {
    after?: string;
    before?: string;
    limit?: number;
  };
}

function HomePage() {
  // Get the trip cart context at component level
  const { setTrip: setTripInCart } = useTripCart();
  const router = useRouter();
  
  const [viewState, setViewState] = useState<ViewState>('initial');
  const [isLoading, setIsLoading] = useState(true);
  const [searchParams, setSearchParams] = useState<SearchParams>({
    budget: 750,
    currency: 'USD',
    originType: 'Airport',
    origin: 'MAD',
    destinationType: 'Airport',
    destination: 'PAR',
    departureDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 1 week from now
    returnDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 2 weeks from now
    tripType: 'roundtrip' as const,
    travelers: 1,
    nights: 7,
    includeHotels: true,
    useKiwi: true, // default to Kiwi
    useDuffel: false
  });
  const [selectedOutbound, setSelectedOutbound] = useState<FlightOffer | null>(null);
  const [selectedReturn, setSelectedReturn] = useState<FlightOffer | null>(null);
  const [tripData, setTripData] = useState<TripDataResponse>({ data: [] });
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [hasMoreResults, setHasMoreResults] = useState(true);
  const [currentPage, setCurrentPage] = useState(1);
  const resultsPerPage = 10; // Number of results to load per page
  const [showReturnFlights, setShowReturnFlights] = useState(false);
  
  // Memoize outbound flights to prevent unnecessary re-renders and filter by origin/destination
  const memoizedOutboundFlights = React.useMemo(() => {
    if (!tripData.data) return [];
    
    return tripData.data.filter(trip => {
      return trip.itineraries?.some(itinerary => 
        itinerary.segments?.some(segment => 
          segment.departure?.iataCode === searchParams.origin &&
          segment.arrival?.iataCode === searchParams.destination
        )
      );
    }).map(trip => ({
      ...trip,
      itineraries: [trip.itineraries?.[0] || { duration: '', segments: [] }]
    }));
  }, [tripData.data, searchParams.origin, searchParams.destination]);
  
  // Handle loading more results with cursor-based pagination
  const loadMoreResults = async () => {
    if (isLoadingMore || !hasMoreResults) return;
    
    setIsLoadingMore(true);
    setError(null);
    
    try {
      const queryParams = new URLSearchParams({
        origin: `${searchParams.originType}:${searchParams.origin}`,
        destination: `${searchParams.destinationType}:${searchParams.destination}`,
        departureDate: searchParams.departureDate,
        returnDate: searchParams.returnDate || '',
        tripType: searchParams.tripType,
        nights: searchParams.nights.toString(),
        travelers: searchParams.travelers.toString(),
        currency: searchParams.currency,
        budget: searchParams.budget.toString(),
        includeHotels: 'false', // Not used in pagination
        useKiwi: 'false', // Always use Duffel for pagination
        useDuffel: 'true',
        limit: resultsPerPage.toString(),
        ...(tripData.meta?.after && { after: tripData.meta.after })
      });
      
      const response = await fetch(`/api/trips?${queryParams}`);
      
      if (!response.ok) {
        throw new Error('Failed to load more results');
      }
      
      const result = await response.json();
      const newData = result.data || [];
      
      if (newData.length > 0) {
        setTripData(prev => ({
          data: [...(prev.data || []), ...newData],
          meta: result.meta || {}
        }));
        
        // Update hasMoreResults based on whether there's an after cursor
        setHasMoreResults(!!result.meta?.after);
      } else {
        setHasMoreResults(false);
      }
    } catch (err) {
      console.error('Error loading more results:', err);
      setError(err instanceof Error ? err.message : 'Failed to load more results');
    } finally {
      setIsLoadingMore(false);
    }
  };
  
  // Handle back to search
  const handleBackToSearch = () => {
    setViewState('initial');
  };

  // Handle flight selection
  const handleSelectOutbound = (flight: FlightOffer) => {
    setSelectedOutbound(flight);
    setSelectedReturn(null); // Reset return selection when changing outbound
  };

  // Handle initial search
  const handleSearch = async (e: React.FormEvent) => {
    e.preventDefault();
    setViewState('searching');
    setError(null);
    
    try {
      const queryParams = new URLSearchParams({
        origin: `${searchParams.originType}:${searchParams.origin}`,
        destination: `${searchParams.destinationType}:${searchParams.destination}`,
        departureDate: searchParams.departureDate,
        returnDate: searchParams.returnDate || '',
        tripType: searchParams.tripType,
        nights: searchParams.nights.toString(),
        travelers: searchParams.travelers.toString(),
        currency: searchParams.currency,
        budget: searchParams.budget.toString(),
        includeHotels: 'false',
        useKiwi: 'false',
        useDuffel: 'true',
        limit: resultsPerPage.toString()
      });
      
      const response = await fetch(`/api/trips?${queryParams}`);
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || 'Failed to fetch trips');
      }
      
      const result = await response.json();
      
      if (!result.data || result.data.length === 0) {
        setViewState('no-results');
        return;
      }
      
      setTripData({
        data: result.data || [],
        meta: result.meta || {}
      });
      
      setHasMoreResults(!!result.meta?.after);
      setViewState('results');
      
    } catch (err) {
      console.error('Search error:', err);
        tripType: searchParams.tripType,
        nights: searchParams.nights.toString(),
        travelers: searchParams.travelers.toString(),
        currency: searchParams.currency,
        budget: searchParams.budget.toString(),
        includeHotels: searchParams.includeHotels ? 'true' : 'false',
        useKiwi: searchParams.useKiwi ? 'true' : 'false',
        useDuffel: 'true', // Force using Duffel for pagination
        limit: resultsPerPage.toString(),
        // Only include after cursor if we have more results to load
        ...(tripData.meta?.after && { after: tripData.meta.after }),
      });
      
      const response = await fetch(`/api/trips?${queryParams}`);
      
      if (!response.ok) {
        throw new Error('Failed to load more results');
      }
      
      const result = await response.json();
      const newData = result.data || [];
      
      if (newData.length > 0) {
        // If this is the first page, replace the data, otherwise append
        setTripData(prev => ({
          data: prev.meta?.after ? [...prev.data, ...newData] : newData,
          meta: result.meta || {}
        }));
        
        // Check if we have more results based on Duffel's pagination
        setHasMoreResults(!!result.meta?.after);
      } else {
        setHasMoreResults(false);
      }
    } catch (error) {
      console.error('Error loading more results:', error);
      setError('Failed to load more results. Please try again.');
    } finally {
      setIsLoadingMore(false);
    }
  };

  // Add scroll listener for infinite scroll (optional)
  useEffect(() => {
    const handleScroll = () => {
      if (
        window.innerHeight + document.documentElement.scrollTop >= 
        document.documentElement.offsetHeight - 100 && 
        !isLoadingMore && 
        hasMoreResults
      ) {
        loadMoreResults();
      }
    };
    
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [isLoadingMore, hasMoreResults]);
  const [error, setError] = useState<string | null>(null);
  const quickSelect = [250, 500, 750, 1000, 1500];
  const popularDestinations = [
    { code: 'PAR', name: 'Paris' },
    { code: 'LON', name: 'London' },
    { code: 'NYC', name: 'New York' },
    { code: 'ROM', name: 'Rome' },
    { code: 'BCN', name: 'Barcelona' },
  ];


  useEffect(() => {
    const timer = setTimeout(() => {
      setIsLoading(false);
    }, 1500);
    return () => clearTimeout(timer);
  }, []);

  // Handler functions are defined later in the file

  // Handle search form submission
  const handleSearch = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    setTripData([]);
    setCurrentPage(1);
    setHasMoreResults(true);
    // Reset all selections when performing a new search
    setViewState('searching');
    setError(null);
    
    try {
      const queryParams = new URLSearchParams({
        origin: `${searchParams.originType}:${searchParams.origin}`,
        destination: `${searchParams.destinationType}:${searchParams.destination}`,
        departureDate: searchParams.departureDate,
        returnDate: searchParams.returnDate || '',
        tripType: searchParams.tripType,
        nights: searchParams.nights.toString(),
        travelers: searchParams.travelers.toString(),
        currency: searchParams.currency,
        budget: searchParams.budget.toString(),
        includeHotels: searchParams.includeHotels ? 'true' : 'false',
        useKiwi: searchParams.useKiwi ? 'true' : 'false',
        useDuffel: 'true', // Always use Duffel for consistency
      });
      
      const response = await fetch(`/api/trips?${queryParams}`);
      
      if (!response.ok) {
        const error = await response.text();
        throw new Error(error || 'Failed to fetch trips');
      }
      
      const result = await response.json();
      setTripData({
        id: trip.id || `trip-${Date.now()}`,
        trip: {
          ...trip,
          price: trip.price,
          itineraries: [...trip.itineraries]
        },
        searchParams: {
          ...searchParams,
          tripType: 'oneway' as const,
          returnDate: '' // Ensure return date is cleared for one-way trips
        }
      };
      
      // First update the cart state
      setTripInCart(tripToBook);
      
      // Then navigate to the booking page
      router.push('/trip-summary');
    } else {
      // For roundtrip, show return flight selection
      setViewState('results');
    }
  };

  // Handle return flight selection (only for roundtrip)
  const handleSelectReturn = (trip: FlightOffer) => {
    setSelectedReturn(trip);
  };

  const handleReset = () => {
    setSelectedOutbound(null);
    setSelectedReturn(null);
    handleBackToSearch();
  };

  // Handle continue to booking
  const handleContinueToBooking = async () => {
    if (!selectedOutbound) return;
    
    try {
      // Create a clean trip object with proper price breakdown
      const tripToBook = {
        id: selectedOutbound.id || `trip-${Date.now()}`,
        trip: {
          ...selectedOutbound,
          price: {
            ...selectedOutbound.price,
            breakdown: {
              outbound: selectedOutbound.price.total,
              return: searchParams.tripType === 'roundtrip' ? (selectedReturn?.price?.total || '0') : '0'
            }
          },
          itineraries: [...selectedOutbound.itineraries]
        },
        searchParams: {
          ...searchParams,
          // Ensure we use the current trip type and clear return date for one-way
          tripType: searchParams.tripType as 'oneway' | 'roundtrip',
          ...(searchParams.tripType === 'oneway' && { returnDate: '' })
        },
        totalPrice: selectedOutbound.price.total
      };
      
      // If it's a roundtrip and we have a return flight, combine the trips
      if (searchParams.tripType === 'roundtrip' && selectedReturn) {
        // Combine outbound and return itineraries
        tripToBook.trip.itineraries = [
          ...selectedOutbound.itineraries,
          ...(selectedReturn.itineraries || [])
        ];
        
        // Calculate total price
        const totalPrice = (parseFloat(selectedOutbound.price.total) + 
                          parseFloat(selectedReturn.price?.total || '0')).toString();
        
        // Update the price with proper breakdown
        tripToBook.trip.price = {
          total: totalPrice,
          currency: selectedOutbound.price.currency,
          breakdown: {
            outbound: selectedOutbound.price.total,
            return: selectedReturn.price?.total || '0'
          }
        };
        
        // Update total price
        tripToBook.totalPrice = totalPrice;
      } else if (searchParams.tripType === 'oneway') {
        // For one-way trips, ensure we have the correct price breakdown
        tripToBook.trip.price = {
          ...selectedOutbound.price,
          breakdown: {
            outbound: selectedOutbound.price.total,
            return: '0'
          }
        };
        tripToBook.totalPrice = selectedOutbound.price.total;
      }
      
      // Save to localStorage for booking
      localStorage.setItem('current_booking_offer', JSON.stringify(tripToBook));
      
      // Update the cart state
      await setTripInCart(tripToBook);
      
      // Navigate to booking page
      router.push('/book');
      
      // Clear selections after navigation
      setSelectedOutbound(null);
      setSelectedReturn(null);
      
      // Reset the view state
      setViewState('results');
    } catch (error) {
      console.error('Error saving trip to cart:', error);
      // Handle error (e.g., show error message to user)
    }
  };

  



  // Error component
  function renderError() {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
        <div className="max-w-md w-full bg-white p-8 rounded-xl shadow-md text-center">
          <h2 className="text-2xl font-bold text-red-600 mb-4">Error</h2>
          <p className="text-gray-700 mb-6">An error occurred while processing your request. Please try again.</p>
          <button
            onClick={() => setViewState('initial')}
            className="px-6 py-2 bg-[#FFA500] text-white rounded-lg hover:bg-orange-600 transition-colors"
          >
            Back to Search
          </button>
        </div>
      </div>
    );
  }

  // Search results component
  function renderSearchResults() {
    return (
    <div className="min-h-screen bg-gray-50 py-12">
      <header className="bg-white shadow-md py-4">
        <div className="container mx-auto px-4 flex justify-between items-center">
          <motion.button
            onClick={handleReset}
            className="text-gray-600 hover:text-[#FFA500] focus:outline-none"
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
          >
            <FiArrowLeft className="inline-block mr-2" /> New Search
          </motion.button>
          <h1 className="text-xl font-semibold text-gray-800">Search Results</h1>
          <div></div>
        </div>
      </header>
      <div className="container mx-auto px-4 mt-8">
        <AnimatePresence>
          {/* Flight Selection */}
          {!selectedOutbound ? (
            <div>
              <h2 className="text-2xl font-bold mb-6 text-gray-800">
                {searchParams.tripType === 'oneway' ? 'Available Flights' : 'Outbound Flights'}
                {memoizedOutboundFlights.length > 0 && ` (${memoizedOutboundFlights.length} options)`}
              </h2>
              {memoizedOutboundFlights.length === 0 ? (
                <div className="text-center py-10">
                  <p className="text-gray-500 text-lg">No flights found.</p>
                  <button 
                    onClick={handleBackToSearch}
                    className="mt-4 text-blue-600 hover:underline"
                  >
                    ← Back to search
                  </button>
                </div>
              ) : (
                <div className="space-y-4">
                  {memoizedOutboundFlights.map((trip) => (
                    <motion.div
                      key={trip.id}
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      exit={{ opacity: 0, y: -20 }}
                      transition={{ duration: 0.3 }}
                    >
                      <TripCard
                        trip={trip}
                        budget={searchParams.budget}
                        searchParams={{
                          ...searchParams,
                          departureDate: searchParams.departureDate,
                          returnDate: searchParams.returnDate || ''
                        }}
                        flightType={searchParams.tripType === 'oneway' ? 'oneway' : 'outbound'}
                        onSelect={() => handleSelectOutbound(trip)}
                        selected={false}
                      />
                    </motion.div>
                  ))}
                  
                  {/* Load More Button */}
                  {hasMoreResults && (
                    <div className="flex justify-center mt-6">
                      <button
                        onClick={loadMoreResults}
                        disabled={isLoadingMore}
                        className={`px-6 py-3 rounded-full font-medium ${
                          isLoadingMore 
                            ? 'bg-gray-300 cursor-not-allowed' 
                            : 'bg-gradient-to-r from-orange-500 to-amber-500 hover:from-orange-600 hover:to-amber-600 text-white shadow-lg hover:shadow-xl transform transition-all duration-200 hover:-translate-y-0.5'
                        }`}
                      >
                        {isLoadingMore ? (
                          <span className="flex items-center">
                            <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Loading...
                          </span>
                        ) : (
                          'Load More Flights'
                        )}
                      </button>
                    </div>
                  )}
                  
                  {!hasMoreResults && memoizedOutboundFlights.length > 0 && (
                    <div className="text-center py-4 text-gray-500">
                      No more flights to show
                    </div>
                  )}
                </div>
              )}
            </div>
          ) : searchParams.tripType === 'roundtrip' ? (
            <div>
              <h2 className="text-xl font-bold mb-4">Review your trip</h2>
              <div className="space-y-8">
                {/* Outbound Flight */}
                <div>
                  <div className="flex justify-between items-center mb-2">
                    <h3 className="text-lg font-semibold">Outbound Flight</h3>
                    <button 
                      onClick={() => setSelectedOutbound(null)}
                      className="text-sm text-blue-600 hover:underline"
                    >
                      Change flight
                    </button>
                  </div>
                  <TripCard
                    trip={{
                      ...selectedOutbound,
                      itineraries: [selectedOutbound.itineraries[0]] // Only show outbound leg
                    }}
                    budget={searchParams.budget}
                    searchParams={{
                      ...searchParams,
                      departureDate: selectedOutbound.itineraries[0]?.segments[0]?.departure?.at
                        ? new Date(selectedOutbound.itineraries[0].segments[0].departure.at).toISOString().split('T')[0]
                        : searchParams.departureDate,
                      returnDate: searchParams.returnDate || ''
                    }}
                    selected={true}
                  />
                </div>

                {/* Return Flight */}
                <div>
                  <h3 className="text-lg font-semibold mb-2">Return Flight</h3>
                  {selectedReturn ? (
                    <TripCard
                      trip={{
                        ...selectedReturn,
                        // Ensure we're using the correct date from the return segments
                        itineraries: selectedReturn.itineraries.map((itinerary: any, idx: number) => ({
                          ...itinerary,
                          // Use the first segment's departure date for the return flight
                          departureDate: itinerary.segments?.[0]?.departure?.at || ''
                        }))
                      }}
                      budget={searchParams.budget}
                      searchParams={{
                        ...searchParams,
                        // Use the return date from the search params for display
                        departureDate: searchParams.returnDate || '',
                        returnDate: ''
                      }}
                      flightType="return"
                      selected={true}
                    />
                  ) : (
                    <div>
                      <p className="text-sm text-yellow-700 mb-2">Please select a return flight:</p>
                      <div className="space-y-4">
                        {/* Show all available return flight options */}
                        {(() => {
                          if (!selectedOutbound) return null;
                          
                          // Find all trips that have the same outbound segment as the selected outbound
                          const returnFlightOptions = tripData
                            .filter(trip => {
                              // Skip trips that don't have exactly 2 itineraries (outbound + return)
                              if (!trip.itineraries || trip.itineraries.length !== 2) return false;
                              
                              // Check if the outbound segments match the selected outbound
                              const outboundSegments = trip.itineraries[0].segments;
                              const selectedSegments = selectedOutbound.itineraries[0].segments;
                              
                              return JSON.stringify(outboundSegments) === JSON.stringify(selectedSegments);
                            })
                            // Map to a new trip object with just the return itinerary
                            .map(trip => {
                              // Get the return itinerary (second one in the array)
                              const returnItinerary = trip.itineraries[1];
                              
                              // Create a new trip object with just the return itinerary
                              return {
                                ...trip,
                                itineraries: [returnItinerary],
                                price: {
                                  ...trip.price,
                                  // Adjust the price to show only the return portion (half of total)
                                  total: (parseFloat(trip.price.total) / 2).toFixed(2)
                                }
                              };
                            })
                            .filter(trip => trip.itineraries[0]?.segments?.length > 0);
                          if (returnFlightOptions.length === 0) {
                            return (
                              <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4">
                                <div className="flex">
                                  <div className="flex-shrink-0">
                                    <svg className="h-5 w-5 text-yellow-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                      <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                                    </svg>
                                  </div>
                                  <div className="ml-3">
                                    <p className="text-sm text-yellow-700">
                                      No return flight options available for this selection.
                                    </p>
                                  </div>
                                </div>
                              </div>
                            );
                          }
                          return returnFlightOptions.map((trip, idx) => (
                            <TripCard
                              key={trip.id + '-return-' + idx}
                              trip={trip}
                              budget={searchParams.budget}
                              searchParams={{
                                ...searchParams,
                                departureDate: searchParams.returnDate || '',
                                returnDate: ''
                              }}
                              flightType="return"
                              onSelect={() => setSelectedReturn(trip)}
                              selected={false}
                            />
                          ));
                        })()}
                      </div>
                    </div>
                  )}
                </div>
              </div>
              
              <div className="mt-8 flex items-center gap-4">
                {searchParams.tripType === 'roundtrip' && (
                  <button
                    className="flex-1 bg-gradient-to-br from-blue-500 to-blue-600 text-white px-6 py-3 rounded-lg font-bold shadow-lg hover:shadow-xl transition-shadow duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={!selectedReturn}
                    onClick={() => {
                      // Create a combined trip with both outbound and return flights
                      const combinedTrip = {
                        ...selectedOutbound,
                        // Preserve the original itineraries structure with proper dates
                        itineraries: [
                          // Keep the outbound itinerary as is
                          selectedOutbound.itineraries[0],
                          // Add the return itinerary if selected
                          ...(selectedReturn ? [selectedReturn.itineraries[0]] : [])
                        ],
                        // Combine prices for round trip
                        price: {
                          ...selectedOutbound.price,
                          // If we have a return flight, add the prices together
                          ...(selectedReturn && {
                            total: (parseFloat(selectedOutbound.price.total) + parseFloat(selectedReturn.price.total)).toFixed(2),
                            breakdown: {
                              outbound: selectedOutbound.price.total,
                              return: selectedReturn.price.total
                            }
                          })
                        } as const // Use const assertion to ensure type safety
                      };
                      
                      // Create a modified searchParams object with the correct dates
                      const updatedSearchParams = {
                        ...searchParams,
                        // Make sure the return date is correctly set from the return flight
                        returnDate: selectedReturn?.itineraries[0]?.segments?.[0]?.departure?.at
                          ? new Date(selectedReturn.itineraries[0].segments[0].departure.at).toISOString().split('T')[0]
                          : searchParams.returnDate
                      };
                      
                      // Format the trip data to match what the booking page expects
                      const formattedTrip = {
                        ...combinedTrip,
                        // Ensure we have the correct price structure
                        price: (() => {
                          const basePrice = {
                            total: combinedTrip.price?.total || '0',
                            currency: combinedTrip.price?.currency || 'USD'
                          };
                          
                          const isRoundTrip = (searchParams.tripType as string) === 'roundtrip';
                          if (isRoundTrip && selectedReturn) {
                            return {
                              ...basePrice,
                              breakdown: {
                                outbound: selectedOutbound.price?.total || '0',
                                return: selectedReturn?.price?.total || '0'
                              }
                            };
                          }
                          return basePrice;
                        })(),
                        // Ensure we have the correct itineraries structure
                        itineraries: (combinedTrip.itineraries || []).map((itinerary: any) => ({
                          ...itinerary,
                          // Ensure segments have the expected structure
                          segments: (itinerary.segments || []).map((segment: any) => ({
                            ...segment,
                            departure: {
                              ...segment.departure,
                              at: segment.departure?.at || segment.departure?.dateTime || ''
                            },
                            arrival: {
                              ...segment.arrival,
                              at: segment.arrival?.at || segment.arrival?.dateTime || ''
                            }
                          }))
                        }))
                      };

                      // Save to localStorage for booking
                      localStorage.setItem('current_booking_offer', JSON.stringify({
                        trip: formattedTrip,
                        searchParams: {
                          ...searchParams,
                          // Ensure we have the required fields for the booking page
                          from: searchParams.origin,
                          to: searchParams.destination,
                          travelers: searchParams.travelers || 1,
                          tripType: searchParams.tripType,
                          // Make sure the return date is cleared for one-way trips
                          returnDate: (searchParams.tripType as string) === 'oneway' ? '' : updatedSearchParams.returnDate,
                          departureDate: searchParams.departureDate
                        },
                        budget: searchParams.budget
                      }));
                      
                      // Navigate to booking page
                      window.location.href = '/book';
                    }}
                  >
                    {(searchParams.tripType as string) === 'oneway' 
                      ? 'Continue to Booking' 
                      : !selectedReturn 
                        ? 'Select Return Flight to Continue' 
                        : 'Book Package'}
                  </button>
                )}
              </div>
            </div>
          ) : (
            <div>
              <h2 className="text-2xl font-bold mb-6 text-gray-800">Select your return flight</h2>
              {outboundFlights.length === 0 ? (
                <div className="text-center py-10">
                  <p className="text-gray-500 text-lg">No return flights found.</p>
                  <button 
                    onClick={handleBackToSearch}
                    className="mt-4 text-blue-600 hover:underline"
                  >
                    ← Back to search
                  </button>
                </div>
              ) : (
                <div className="space-y-4">
                  {outboundFlights.map((trip) => (
                    <motion.div
                      key={trip.id}
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      exit={{ opacity: 0, y: -20 }}
                      transition={{ duration: 0.3 }}
                    >
                      <TripCard
                        trip={trip}
                        budget={searchParams.budget}
                        searchParams={{
                          ...searchParams,
                          departureDate: searchParams.departureDate,
                          returnDate: searchParams.returnDate || ''
                        }}
                        flightType="return"
                        onSelect={() => handleSelectReturn(trip)}
                        selected={false}
                      />
                    </motion.div>
                  ))}
                </div>
              )}
            </div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );

  const renderError = () => (
    <div className="min-h-screen bg-gray-100 flex flex-col justify-center items-center">
      <h2 className="text-3xl font-bold text-red-500 mb-4">Oops! An Error Occurred</h2>
      <p className="text-gray-700 mb-4">{error}</p>
      <motion.button
        onClick={handleBackToSearch}
        className="bg-gradient-to-br from-[#FFA500] to-[#FF8C00] text-white py-3 px-6 rounded-xl font-medium shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-[#FFA500] focus:ring-opacity-50"
        whileHover={{ scale: 1.02 }}
        whileTap={{ scale: 0.98 }}
      >
        Back to Search
      </motion.button>
    </div>
  );

  const renderSearching = () => (
    <div className="min-h-screen bg-gray-100 flex flex-col justify-center items-center">
      <h2 className="text-3xl font-semibold text-gray-800 mb-4">Searching for the best trips...</h2>
      <div className="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-[#FFA500] mb-4"></div>
      <p className="text-gray-600">Please wait while we find amazing deals for you.</p>
    </div>
  );

  if (viewState === 'searching') {
    return renderSearching();
  }

  const renderSearchResults = () => (
    <div className="min-h-screen bg-gray-100">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <AnimatePresence mode="wait">
          {!showReturnFlights ? (
            <div>
              <h2 className="text-2xl font-bold mb-6 text-gray-800">Select your outbound flight</h2>
              {outboundFlights.length === 0 ? (
                <div className="text-center py-10">
                  <p className="text-gray-500 text-lg">No flights found. Please try different search criteria.</p>
                  <button 
                    onClick={handleBackToSearch}
                    className="mt-4 text-blue-600 hover:underline"
                  >
                    ← Back to search
                  </button>
                </div>
              ) : (
                <div className="space-y-4">
                  {outboundFlights.map((trip) => (
                    <motion.div
                      key={trip.id}
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      exit={{ opacity: 0, y: -20 }}
                      transition={{ duration: 0.3 }}
                    >
                      <TripCard
                        trip={trip}
                        budget={searchParams.budget}
                        searchParams={{
                          ...searchParams,
                          departureDate: searchParams.departureDate,
                          returnDate: searchParams.returnDate || ''
                        }}
                        flightType="outbound"
                        onSelect={() => handleSelectOutbound(trip)}
                        selected={selectedOutbound?.id === trip.id}
                      />
                    </motion.div>
                  ))}
                </div>
              )}
              
              <div className="mt-8 flex justify-between items-center">
                <button
                  className="text-gray-600 hover:text-gray-800 underline transition-colors duration-200"
                  onClick={handleBackToSearch}
                >
                  ← Back to search
                </button>
                
                <button
                  className="bg-gradient-to-br from-[#FFA500] to-[#FF8C00] text-white px-6 py-3 rounded-xl font-medium shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-[#FFA500] focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled={!selectedOutbound}
                  onClick={() => {
                    if (!selectedOutbound) return;
                    
                    if (searchParams.tripType === 'oneway') {
                      // For one-way trips, proceed directly to booking
                      const tripToBook = {
                        ...selectedOutbound,
                        price: {
                          ...selectedOutbound.price,
                          breakdown: {
                            outbound: selectedOutbound.price.total,
                            return: '0'
                          }
                        }
                      };

                      // Save the full trip object (including searchParams) for booking
                      localStorage.setItem('current_booking_offer', JSON.stringify({
                        trip: tripToBook,
                        searchParams: {
                          ...searchParams,
                          from: searchParams.origin,
                          to: searchParams.destination,
                          travelers: searchParams.travelers || 1,
                          tripType: searchParams.tripType,
                          returnDate: '', // Clear return date for one-way trips
                          departureDate: searchParams.departureDate
                        },
                        budget: searchParams.budget
                      }));
                      
                      // Navigate to booking page
                      window.location.href = '/book';
                    } else {
                      // For round-trip, show return flights
                      setShowReturnFlights(true);
                    }
                  }}
                >
                  {(searchParams.tripType as string) === 'oneway' 
                    ? 'Continue to Booking' 
                    : !selectedReturn 
                      ? 'Select Return Flight to Continue' 
                      : 'Book Package'}
                </button>
                
                <button
                  className="text-gray-600 hover:text-gray-800 underline transition-colors duration-200"
                  onClick={handleReset}
                >
                  Start Over
                </button>
              </div>
            </div>
          ) : (
            <div>
              <h2 className="text-2xl font-bold mb-6 text-gray-800">Select your return flight</h2>
              {outboundFlights.length === 0 ? (
                <div className="text-center py-10">
                  <p className="text-gray-500 text-lg">No return flights found.</p>
                  <button 
                    onClick={handleBackToSearch}
                    className="mt-4 text-blue-600 hover:underline"
                  >
                    ← Back to search
                  </button>
                </div>
              ) : (
                <div className="space-y-4">
                  {outboundFlights.map((trip) => (
                    <motion.div
                      key={trip.id}
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      exit={{ opacity: 0, y: -20 }}
                      transition={{ duration: 0.3 }}
                    >
                      <TripCard
                        trip={trip}
                        budget={searchParams.budget}
                        searchParams={{
                          ...searchParams,
                          departureDate: searchParams.departureDate,
                          returnDate: searchParams.returnDate || ''
                        }}
                        flightType="return"
                        onSelect={() => handleSelectReturn(trip)}
                        selected={false}
                      />
                    </motion.div>
                  ))}
                </div>
              )}
            </div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
  }

  if (viewState === 'results') {
    return renderSearchResults();
  }

  if (viewState === 'error') {
    return renderError();
  }

  return renderSearchForm();
}

export default HomePage;